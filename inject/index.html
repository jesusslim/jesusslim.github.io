<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
</head>
<title>Crm</title>

<xmp theme="united" style="display:none;">
# 闭包与依赖注入

Slim

## Closure 闭包

### 闭包定义

匿名函数

### 闭包的好处

[参考](http://www.cnblogs.com/yjf512/archive/2012/10/29/2744702.html)

#### 减少foreach循环代码

	array_walk array_map
	
#### 减少函数的参数

#### 解除递归函数

#### 延迟绑定

中间件

### .
	
闭包的代码相对优雅，但是逻辑比较容易混淆。

建议在代码结构比较乱，需要封装的时候使用。


## 依赖注入

### 概念

	依赖注入(Dependency Injection)和控制反转(Inversion of Control)是同一个概念。具体含义是:当某个角色(可能是一个Java实例，调用者)需要另一个角色(另一个Java实例，被调用者)的协助时，在 传统的程序设计过程中，通常由调用者来创建被调用者的实例。但在Spring里，创建被调用者的工作不再由调用者来完成，因此称为控制反转;创建被调用者 实例的工作通常由Spring容器来完成，然后注入调用者，因此也称为依赖注入。
	
	不管是依赖注入，还是控制反转，都说明Spring采用动态、灵活的方式来管理各种对象。对象与对象之间的具体实现互相透明。在理解依赖注入之前，看如下这个问题在各种社会形态里如何解决:一个人(Java实例，调用者)需要一把斧子(Java实例，被调用者)。

	(1)原始社会里，几乎没有社会分工。需要斧子的人(调用者)只能自己去磨一把斧子(被调用者)。对应的情形为:Java程序里的调用者自己创建被调用者。

	(2)进入工业社会，工厂出现。斧子不再由普通人完成，而在工厂里被生产出来，此时需要斧子的人(调用者)找到工厂，购买斧子，无须关心斧子的制造过程。对应Java程序的简单工厂的设计模式。

	(3)进入“按需分配”社会，需要斧子的人不需要找到工厂，坐在家里发出一个简单指令:需要斧子。斧子就自然出现在他面前。对应Spring的依赖注入。
	
参考 [golang: Martini之inject源码分析](http://my.oschina.net/goal/blog/195036)	
	
### 好处

将被依赖类的创建代码从 依赖类中移出，不用显式的写new。

可以单独维护被依赖类的创建过程。方便该类的被共享。 如果该类初始化时，所需属性很多，使用配置，远比硬代码编写简单.

有多层依赖时，依赖关系的移出，事实上简化了 依赖关系的查看和维护。
因为对每个类而言，只需要关心这个类的依赖。

大大降低耦合性。

### 缺点

缺少IDE支持

对象生成因为是使用反射编程，在效率上有些损耗。但相对于IoC提高的维护性和灵活性来说，这点损耗是微不足道的，除非某对象的生成对效率要求特别高。

可读性受影响。

### .

java Spring

golang Martini [Inject](https://github.com/codegangsta/inject)

php laravel zanphp

## 例子

</xmp>

<script src="http://strapdownjs.com/v/0.2/strapdown.js"></script>
</html>